"""Self-Discovery Cycle (SDC) Module.

Implements the autonomous discovery loop from the QRATUM ASCENSION DIRECTIVE:

    while true:
        generate hypothesis H_i
        derive state-space model M_i
        execute bounded AAS search on M_i
        evaluate empirical delta Δ_i
        if Δ_i > threshold:
            commit to Discovery Ledger
            spawn verification agents

No human curation inside the loop.
"""

from __future__ import annotations

import hashlib
import time
import uuid
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Callable, Generic, TypeVar

from qratum.metrics import QRATUMMetrics


State = TypeVar("State")
Action = TypeVar("Action")


class DiscoveryStatus(Enum):
    """Status of a discovery in the ledger."""

    PENDING = "pending"
    VERIFIED = "verified"
    REJECTED = "rejected"
    ARCHIVED = "archived"


@dataclass
class Hypothesis:
    """A hypothesis generated by the discovery engine.

    Represents a testable proposition about the state space.
    """

    hypothesis_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    description: str = ""
    domain: str = ""
    parameters: dict[str, Any] = field(default_factory=dict)
    confidence: float = 0.0
    timestamp: float = field(default_factory=time.time)
    parent_hypothesis_id: str | None = None  # For hypothesis chains

    def hash(self) -> str:
        """Compute deterministic hash of hypothesis."""
        content = f"{self.description}|{self.domain}|{sorted(self.parameters.items())}"
        return hashlib.sha256(content.encode()).hexdigest()[:16]


@dataclass
class StateSpaceModel:
    """A state-space model derived from a hypothesis.

    Defines the search space for AAS exploration.
    """

    model_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    hypothesis_id: str = ""
    state_dimensions: int = 0
    action_space_size: int = 0
    branching_factor: float = 1.0
    estimated_complexity: float = 1.0
    constraints: list[str] = field(default_factory=list)
    metadata: dict[str, Any] = field(default_factory=dict)


@dataclass
class SearchResult:
    """Result of an AAS search on a state-space model."""

    model_id: str
    best_state: Any
    best_value: float
    nodes_explored: int
    time_elapsed_ms: float
    depth_reached: int
    confidence: float


@dataclass
class EmpiricalDelta:
    """Empirical delta measuring discovery significance.

    Δ_i represents the improvement/change from baseline.
    """

    delta_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    model_id: str = ""
    baseline_value: float = 0.0
    actual_value: float = 0.0
    delta: float = 0.0  # actual - baseline
    relative_delta: float = 0.0  # (actual - baseline) / baseline
    statistical_significance: float = 0.0
    timestamp: float = field(default_factory=time.time)

    @property
    def exceeds_threshold(self) -> bool:
        """Check if delta exceeds significance threshold."""
        # Default threshold: 10% improvement with >95% confidence
        return self.relative_delta > 0.1 and self.statistical_significance > 0.95


@dataclass
class DiscoveryEntry:
    """An entry in the Discovery Ledger."""

    entry_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    hypothesis: Hypothesis = field(default_factory=Hypothesis)
    model: StateSpaceModel = field(default_factory=StateSpaceModel)
    search_result: SearchResult | None = None
    empirical_delta: EmpiricalDelta | None = None
    status: DiscoveryStatus = DiscoveryStatus.PENDING
    verification_count: int = 0
    verification_results: list[bool] = field(default_factory=list)
    created_at: float = field(default_factory=time.time)
    verified_at: float | None = None
    metadata: dict[str, Any] = field(default_factory=dict)

    def hash(self) -> str:
        """Compute ledger entry hash for chain integrity."""
        content = (
            f"{self.entry_id}|{self.hypothesis.hash()}|"
            f"{self.status.value}|{self.created_at}"
        )
        return hashlib.sha256(content.encode()).hexdigest()


class DiscoveryLedger:
    """Append-only ledger for discoveries.

    Implements cryptographic chaining for integrity verification.
    """

    def __init__(self) -> None:
        """Initialize empty ledger."""
        self._entries: list[DiscoveryEntry] = []
        self._chain_hashes: list[str] = []
        self._entry_hashes: list[str] = []  # Store entry hashes at commit time
        self._genesis_hash = hashlib.sha256(b"QRATUM_GENESIS").hexdigest()
        self._chain_hashes.append(self._genesis_hash)

    def commit(self, entry: DiscoveryEntry) -> str:
        """Commit a discovery entry to the ledger.

        Args:
            entry: Discovery entry to commit.

        Returns:
            Chain hash for the committed entry.
        """
        # Compute entry hash at commit time (before any modifications)
        entry_hash = entry.hash()

        # Chain with previous hash
        previous_hash = self._chain_hashes[-1]
        chain_hash = hashlib.sha256(
            f"{previous_hash}|{entry_hash}".encode()
        ).hexdigest()

        self._entries.append(entry)
        self._entry_hashes.append(entry_hash)  # Store the hash at commit time
        self._chain_hashes.append(chain_hash)

        return chain_hash

    def verify_chain(self) -> bool:
        """Verify integrity of the entire ledger chain.

        Returns:
            True if chain is valid, False otherwise.
        """
        if not self._entries:
            return True

        previous_hash = self._genesis_hash
        for i, entry_hash in enumerate(self._entry_hashes):
            expected_chain_hash = hashlib.sha256(
                f"{previous_hash}|{entry_hash}".encode()
            ).hexdigest()

            if self._chain_hashes[i + 1] != expected_chain_hash:
                return False

            previous_hash = self._chain_hashes[i + 1]

        return True

    def get_verified_discoveries(self) -> list[DiscoveryEntry]:
        """Get all verified discoveries.

        Returns:
            List of entries with VERIFIED status.
        """
        return [e for e in self._entries if e.status == DiscoveryStatus.VERIFIED]

    def get_pending_verification(self) -> list[DiscoveryEntry]:
        """Get discoveries pending verification.

        Returns:
            List of entries with PENDING status.
        """
        return [e for e in self._entries if e.status == DiscoveryStatus.PENDING]

    def __len__(self) -> int:
        """Return number of entries in ledger."""
        return len(self._entries)


class VerificationAgent(ABC):
    """Abstract verification agent for discovery validation."""

    @abstractmethod
    def verify(self, entry: DiscoveryEntry) -> bool:
        """Verify a discovery entry.

        Args:
            entry: Entry to verify.

        Returns:
            True if verification passes, False otherwise.
        """
        ...


class ReplayVerificationAgent(VerificationAgent):
    """Verifies discoveries by replaying the search."""

    def __init__(self, search_func: Callable) -> None:
        """Initialize with search function.

        Args:
            search_func: Function to execute search.
        """
        self.search_func = search_func

    def verify(self, entry: DiscoveryEntry) -> bool:
        """Verify by replaying search and comparing results.

        Args:
            entry: Entry to verify.

        Returns:
            True if replay matches original result.
        """
        if not entry.search_result:
            return False

        # Replay search
        try:
            replay_result = self.search_func(entry.model)

            # Compare with original (allow small tolerance)
            value_match = (
                abs(replay_result.best_value - entry.search_result.best_value) < 0.01
            )
            return value_match
        except Exception:
            return False


class StatisticalVerificationAgent(VerificationAgent):
    """Verifies discoveries using statistical analysis."""

    def __init__(self, min_samples: int = 10, confidence_threshold: float = 0.95) -> None:
        """Initialize agent.

        Args:
            min_samples: Minimum samples for statistical validity.
            confidence_threshold: Required confidence level.
        """
        self.min_samples = min_samples
        self.confidence_threshold = confidence_threshold

    def verify(self, entry: DiscoveryEntry) -> bool:
        """Verify using statistical significance.

        Args:
            entry: Entry to verify.

        Returns:
            True if statistically significant.
        """
        if not entry.empirical_delta:
            return False

        # Check basic thresholds
        if entry.empirical_delta.statistical_significance < self.confidence_threshold:
            return False

        if entry.empirical_delta.relative_delta <= 0:
            return False

        return True


class SelfDiscoveryCycle(Generic[State, Action]):
    """Autonomous Self-Discovery Cycle (SDC) implementation.

    Continuously generates hypotheses, tests them via bounded AAS search,
    and commits significant discoveries to the ledger.
    """

    def __init__(
        self,
        domain: str,
        hypothesis_generator: Callable[[], Hypothesis],
        model_deriver: Callable[[Hypothesis], StateSpaceModel],
        search_executor: Callable[[StateSpaceModel], SearchResult],
        delta_evaluator: Callable[[SearchResult, StateSpaceModel], EmpiricalDelta],
        delta_threshold: float = 0.1,
        max_iterations: int | None = None,
    ) -> None:
        """Initialize SDC.

        Args:
            domain: Domain identifier.
            hypothesis_generator: Function to generate hypotheses.
            model_deriver: Function to derive state-space models.
            search_executor: Function to execute bounded AAS search.
            delta_evaluator: Function to evaluate empirical delta.
            delta_threshold: Minimum relative delta for commitment.
            max_iterations: Maximum iterations (None = infinite).
        """
        self.domain = domain
        self.hypothesis_generator = hypothesis_generator
        self.model_deriver = model_deriver
        self.search_executor = search_executor
        self.delta_evaluator = delta_evaluator
        self.delta_threshold = delta_threshold
        self.max_iterations = max_iterations

        self.ledger = DiscoveryLedger()
        self.verification_agents: list[VerificationAgent] = []
        self.metrics = QRATUMMetrics()

        # Iteration tracking
        self._iteration_count = 0
        self._running = False

    def add_verification_agent(self, agent: VerificationAgent) -> None:
        """Add a verification agent.

        Args:
            agent: Verification agent to add.
        """
        self.verification_agents.append(agent)

    def run_iteration(self) -> DiscoveryEntry | None:
        """Execute one iteration of the discovery cycle.

        Returns:
            Discovery entry if committed, None otherwise.
        """
        self._iteration_count += 1
        self.metrics.record_operation(external=False, deterministic=True)

        # 1. Generate hypothesis H_i
        hypothesis = self.hypothesis_generator()
        hypothesis.domain = self.domain

        # 2. Derive state-space model M_i
        model = self.model_deriver(hypothesis)
        model.hypothesis_id = hypothesis.hypothesis_id

        # 3. Execute bounded AAS search on M_i
        search_result = self.search_executor(model)

        # 4. Evaluate empirical delta Δ_i
        delta = self.delta_evaluator(search_result, model)
        delta.model_id = model.model_id

        # 5. Check threshold and commit
        if delta.relative_delta > self.delta_threshold:
            entry = DiscoveryEntry(
                hypothesis=hypothesis,
                model=model,
                search_result=search_result,
                empirical_delta=delta,
                status=DiscoveryStatus.PENDING,
            )

            # Commit to Discovery Ledger
            self.ledger.commit(entry)

            # Spawn verification agents
            self._spawn_verification(entry)

            # Update metrics
            self.metrics.record_outcome(
                actual=delta.actual_value, baseline=delta.baseline_value
            )

            return entry

        return None

    def _spawn_verification(self, entry: DiscoveryEntry) -> None:
        """Spawn verification agents for an entry.

        Args:
            entry: Entry to verify.
        """
        if not self.verification_agents:
            # No agents = auto-verify
            entry.status = DiscoveryStatus.VERIFIED
            entry.verified_at = time.time()
            return

        results = []
        for agent in self.verification_agents:
            try:
                result = agent.verify(entry)
                results.append(result)
                entry.verification_results.append(result)
                entry.verification_count += 1
            except Exception:
                results.append(False)
                entry.verification_results.append(False)

        # Require majority agreement
        if sum(results) > len(results) / 2:
            entry.status = DiscoveryStatus.VERIFIED
            entry.verified_at = time.time()
        else:
            entry.status = DiscoveryStatus.REJECTED

    def run(self, iterations: int | None = None) -> list[DiscoveryEntry]:
        """Run the discovery cycle.

        Args:
            iterations: Number of iterations (overrides max_iterations).

        Returns:
            List of committed discoveries.
        """
        self._running = True
        max_iter = iterations or self.max_iterations
        discoveries = []

        iteration = 0
        while self._running:
            if max_iter and iteration >= max_iter:
                break

            entry = self.run_iteration()
            if entry:
                discoveries.append(entry)

            iteration += 1

        return discoveries

    def stop(self) -> None:
        """Stop the discovery cycle."""
        self._running = False

    def get_metrics(self) -> QRATUMMetrics:
        """Get current metrics.

        Returns:
            QRATUM metrics for this module.
        """
        return self.metrics

    @property
    def iteration_count(self) -> int:
        """Return total iterations executed."""
        return self._iteration_count

    @property
    def discovery_count(self) -> int:
        """Return number of discoveries in ledger."""
        return len(self.ledger)

    @property
    def verified_count(self) -> int:
        """Return number of verified discoveries."""
        return len(self.ledger.get_verified_discoveries())


# Factory for creating domain-specific SDC instances
def create_sdc_for_domain(domain: str, **kwargs) -> SelfDiscoveryCycle:
    """Create an SDC instance for a specific domain.

    Args:
        domain: Domain identifier.
        **kwargs: Domain-specific configuration.

    Returns:
        Configured SDC instance.

    Raises:
        ValueError: If domain is not supported.
    """
    if domain.lower() == "chess":
        return _create_chess_sdc(**kwargs)
    else:
        raise ValueError(f"Unknown domain: {domain}")


def _create_chess_sdc(**kwargs) -> SelfDiscoveryCycle:
    """Create SDC for chess domain."""

    def generate_hypothesis() -> Hypothesis:
        """Generate chess-domain hypotheses."""
        import random

        hypotheses = [
            ("piece_coordination", {"piece_types": ["knight", "bishop"]}),
            ("king_safety", {"zone": "kingside"}),
            ("pawn_structure", {"structure_type": "isolated"}),
            ("center_control", {"squares": ["d4", "d5", "e4", "e5"]}),
            ("open_files", {"file": random.choice("abcdefgh")}),
        ]
        desc, params = random.choice(hypotheses)
        return Hypothesis(description=desc, parameters=params, confidence=0.5)

    def derive_model(hyp: Hypothesis) -> StateSpaceModel:
        """Derive state-space model from hypothesis."""
        # Model complexity based on hypothesis type
        complexity_map = {
            "piece_coordination": 100,
            "king_safety": 50,
            "pawn_structure": 150,
            "center_control": 80,
            "open_files": 60,
        }
        return StateSpaceModel(
            hypothesis_id=hyp.hypothesis_id,
            state_dimensions=64,  # 8x8 board
            action_space_size=complexity_map.get(hyp.description, 100),
            branching_factor=30.0,  # Typical chess branching
        )

    def execute_search(model: StateSpaceModel) -> SearchResult:
        """Execute bounded search on model."""
        import random

        # Simulated search result
        return SearchResult(
            model_id=model.model_id,
            best_state=None,
            best_value=random.uniform(0.4, 0.6),
            nodes_explored=model.action_space_size * 100,
            time_elapsed_ms=random.uniform(10, 100),
            depth_reached=6,
            confidence=random.uniform(0.7, 0.95),
        )

    def evaluate_delta(result: SearchResult, model: StateSpaceModel) -> EmpiricalDelta:
        """Evaluate empirical delta."""
        baseline = 0.5  # Neutral evaluation baseline
        delta = result.best_value - baseline
        return EmpiricalDelta(
            model_id=model.model_id,
            baseline_value=baseline,
            actual_value=result.best_value,
            delta=delta,
            relative_delta=abs(delta) / baseline if baseline != 0 else 0,
            statistical_significance=result.confidence,
        )

    return SelfDiscoveryCycle(
        domain="chess",
        hypothesis_generator=generate_hypothesis,
        model_deriver=derive_model,
        search_executor=execute_search,
        delta_evaluator=evaluate_delta,
        **kwargs,
    )
