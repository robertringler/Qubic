"""Tests for QRATUM Vulnerability Discovery Engine."""

import pytest
from qratum_asi.core.vulnerability_discovery import (
    VulnerabilityDiscoveryEngine,
    Subsystem,
    Interface,
    SubsystemType,
    InterfaceType,
    DependencyGraph,
    LatentRiskMetrics,
    EntropyBottleneck,
    CouplingDrift,
    PhaseTransitionRisk,
)


class TestSubsystem:
    """Test Subsystem class."""
    
    def test_subsystem_creation(self):
        """Test creating a subsystem."""
        subsystem = Subsystem(
            subsystem_id="test_001",
            name="Test Subsystem",
            subsystem_type=SubsystemType.GENOMICS_PIPELINE,
            description="Test description",
            interfaces=["if1", "if2"],
            dependencies=["dep1"],
            metadata={"key": "value"}
        )
        
        assert subsystem.subsystem_id == "test_001"
        assert subsystem.name == "Test Subsystem"
        assert subsystem.subsystem_type == SubsystemType.GENOMICS_PIPELINE
        assert len(subsystem.interfaces) == 2
        assert len(subsystem.dependencies) == 1


class TestInterface:
    """Test Interface class."""
    
    def test_interface_creation(self):
        """Test creating an interface."""
        interface = Interface(
            interface_id="if_001",
            name="Test Interface",
            interface_type=InterfaceType.DATA_FLOW,
            source_subsystem="src_001",
            target_subsystem="tgt_001",
            protocol="gRPC",
            metadata={"bandwidth": "1 GB/s"}
        )
        
        assert interface.interface_id == "if_001"
        assert interface.name == "Test Interface"
        assert interface.interface_type == InterfaceType.DATA_FLOW
        assert interface.source_subsystem == "src_001"
        assert interface.target_subsystem == "tgt_001"


class TestDependencyGraph:
    """Test DependencyGraph class."""
    
    def test_add_vertex(self):
        """Test adding vertices to the graph."""
        graph = DependencyGraph()
        subsystem = Subsystem(
            subsystem_id="test_001",
            name="Test",
            subsystem_type=SubsystemType.AION_RUNTIME,
            description="Test"
        )
        
        graph.add_vertex(subsystem)
        
        assert "test_001" in graph.vertices
        assert graph.vertices["test_001"] == subsystem
    
    def test_add_edge(self):
        """Test adding edges to the graph."""
        graph = DependencyGraph()
        
        s1 = Subsystem("s1", "Sub1", SubsystemType.AION_RUNTIME, "Test")
        s2 = Subsystem("s2", "Sub2", SubsystemType.SCHEDULER, "Test")
        
        graph.add_vertex(s1)
        graph.add_vertex(s2)
        graph.add_edge("s1", "s2", 0.8)
        
        assert len(graph.edges) == 1
        assert graph.edges[0] == ("s1", "s2", 0.8)
        assert graph.get_coupling_strength("s1", "s2") == 0.8
    
    def test_get_dependencies(self):
        """Test getting dependencies for a subsystem."""
        graph = DependencyGraph()
        
        s1 = Subsystem("s1", "Sub1", SubsystemType.AION_RUNTIME, "Test")
        s2 = Subsystem("s2", "Sub2", SubsystemType.SCHEDULER, "Test")
        s3 = Subsystem("s3", "Sub3", SubsystemType.MEMORY_MANAGER, "Test")
        
        graph.add_vertex(s1)
        graph.add_vertex(s2)
        graph.add_vertex(s3)
        
        graph.add_edge("s1", "s2", 0.8)
        graph.add_edge("s1", "s3", 0.6)
        
        deps = graph.get_dependencies("s1")
        assert len(deps) == 2
        assert "s2" in deps
        assert "s3" in deps
    
    def test_detect_cycles_no_cycle(self):
        """Test cycle detection with no cycles."""
        graph = DependencyGraph()
        
        s1 = Subsystem("s1", "Sub1", SubsystemType.AION_RUNTIME, "Test")
        s2 = Subsystem("s2", "Sub2", SubsystemType.SCHEDULER, "Test")
        s3 = Subsystem("s3", "Sub3", SubsystemType.MEMORY_MANAGER, "Test")
        
        graph.add_vertex(s1)
        graph.add_vertex(s2)
        graph.add_vertex(s3)
        
        graph.add_edge("s1", "s2", 1.0)
        graph.add_edge("s2", "s3", 1.0)
        
        cycles = graph.detect_cycles()
        assert len(cycles) == 0
    
    def test_detect_cycles_with_cycle(self):
        """Test cycle detection with a cycle."""
        graph = DependencyGraph()
        
        s1 = Subsystem("s1", "Sub1", SubsystemType.AION_RUNTIME, "Test")
        s2 = Subsystem("s2", "Sub2", SubsystemType.SCHEDULER, "Test")
        s3 = Subsystem("s3", "Sub3", SubsystemType.MEMORY_MANAGER, "Test")
        
        graph.add_vertex(s1)
        graph.add_vertex(s2)
        graph.add_vertex(s3)
        
        graph.add_edge("s1", "s2", 1.0)
        graph.add_edge("s2", "s3", 1.0)
        graph.add_edge("s3", "s1", 1.0)  # Creates cycle
        
        cycles = graph.detect_cycles()
        assert len(cycles) > 0


class TestVulnerabilityDiscoveryEngine:
    """Test VulnerabilityDiscoveryEngine class."""
    
    def test_initialization(self):
        """Test engine initialization."""
        engine = VulnerabilityDiscoveryEngine()
        
        assert len(engine.subsystems) == 0
        assert len(engine.interfaces) == 0
        assert engine.dependency_graph is not None
    
    def test_enumerate_subsystem(self):
        """Test enumerating a subsystem."""
        engine = VulnerabilityDiscoveryEngine()
        
        subsystem = Subsystem(
            subsystem_id="test_001",
            name="Test Subsystem",
            subsystem_type=SubsystemType.GENOMICS_PIPELINE,
            description="Test"
        )
        
        engine.enumerate_subsystem(subsystem)
        
        assert "test_001" in engine.subsystems
        assert "test_001" in engine.dependency_graph.vertices
    
    def test_register_interface(self):
        """Test registering an interface."""
        engine = VulnerabilityDiscoveryEngine()
        
        s1 = Subsystem("s1", "Sub1", SubsystemType.AION_RUNTIME, "Test")
        s2 = Subsystem("s2", "Sub2", SubsystemType.SCHEDULER, "Test")
        
        engine.enumerate_subsystem(s1)
        engine.enumerate_subsystem(s2)
        
        interface = Interface(
            interface_id="if_001",
            name="Test Interface",
            interface_type=InterfaceType.DATA_FLOW,
            source_subsystem="s1",
            target_subsystem="s2",
            protocol="gRPC"
        )
        
        engine.register_interface(interface)
        
        assert "if_001" in engine.interfaces
        assert len(engine.dependency_graph.edges) > 0
    
    def test_compute_latent_risk_metrics(self):
        """Test computing latent risk metrics."""
        engine = VulnerabilityDiscoveryEngine()
        
        subsystem = Subsystem(
            subsystem_id="test_001",
            name="Test Subsystem",
            subsystem_type=SubsystemType.GENOMICS_PIPELINE,
            description="Test",
            interfaces=["if1", "if2"],
            dependencies=["dep1"]
        )
        
        engine.enumerate_subsystem(subsystem)
        
        metrics = engine.compute_latent_risk_metrics("test_001")
        
        assert isinstance(metrics, LatentRiskMetrics)
        assert metrics.defect_density >= 0
        assert 0 <= metrics.resilience_elasticity <= 1
        assert metrics.coupling_volatility >= 0
        assert metrics.recovery_half_life > 0
        assert metrics.entropy_local >= 0
        assert metrics.entropy_average >= 0
    
    def test_detect_entropy_bottlenecks(self):
        """Test detecting entropy bottlenecks."""
        engine = VulnerabilityDiscoveryEngine()
        
        # Create subsystem with high complexity
        subsystem = Subsystem(
            subsystem_id="complex_001",
            name="Complex Subsystem",
            subsystem_type=SubsystemType.ORCHESTRATION,
            description="Test",
            interfaces=["if1", "if2", "if3", "if4", "if5"],
            dependencies=["d1", "d2", "d3", "d4", "d5"]
        )
        
        engine.enumerate_subsystem(subsystem)
        
        # Create simple subsystem for comparison
        simple = Subsystem(
            subsystem_id="simple_001",
            name="Simple Subsystem",
            subsystem_type=SubsystemType.MERKLE_CHAIN,
            description="Test",
            interfaces=["if1"],
            dependencies=[]
        )
        
        engine.enumerate_subsystem(simple)
        
        bottlenecks = engine.detect_entropy_bottlenecks()
        
        assert isinstance(bottlenecks, list)
        # Complex subsystem should have higher entropy
        if len(bottlenecks) > 0:
            assert all(isinstance(bn, EntropyBottleneck) for bn in bottlenecks)
    
    def test_track_coupling_drift(self):
        """Test tracking coupling drift."""
        engine = VulnerabilityDiscoveryEngine()
        
        s1 = Subsystem("s1", "Sub1", SubsystemType.AION_RUNTIME, "Test")
        s2 = Subsystem("s2", "Sub2", SubsystemType.SCHEDULER, "Test")
        
        engine.enumerate_subsystem(s1)
        engine.enumerate_subsystem(s2)
        
        interface = Interface(
            interface_id="if_001",
            name="Test Interface",
            interface_type=InterfaceType.DATA_FLOW,
            source_subsystem="s1",
            target_subsystem="s2",
            protocol="gRPC"
        )
        
        engine.register_interface(interface)
        
        drifts = engine.track_coupling_drift()
        
        assert isinstance(drifts, list)
        assert all(isinstance(d, CouplingDrift) for d in drifts)
    
    def test_model_phase_transition(self):
        """Test phase transition modeling."""
        engine = VulnerabilityDiscoveryEngine()
        
        # Add some subsystems
        for i in range(3):
            subsystem = Subsystem(
                subsystem_id=f"test_{i:03d}",
                name=f"Test {i}",
                subsystem_type=SubsystemType.AION_RUNTIME,
                description="Test"
            )
            engine.enumerate_subsystem(subsystem)
        
        phase_risk = engine.model_phase_transition()
        
        assert isinstance(phase_risk, PhaseTransitionRisk)
        assert 0 <= phase_risk.system_health <= 1
        assert 0 <= phase_risk.collapse_probability <= 1
        assert isinstance(phase_risk.variance_spike, bool)
        assert isinstance(phase_risk.entropy_localization, bool)
        assert isinstance(phase_risk.resilience_compression, bool)
        assert isinstance(phase_risk.precursor_signals, list)
    
    def test_generate_metrics_report(self):
        """Test generating a complete metrics report."""
        engine = VulnerabilityDiscoveryEngine()
        
        # Add subsystems
        subsystem = Subsystem(
            subsystem_id="test_001",
            name="Test Subsystem",
            subsystem_type=SubsystemType.GENOMICS_PIPELINE,
            description="Test"
        )
        
        engine.enumerate_subsystem(subsystem)
        
        report = engine.generate_metrics_report()
        
        assert report.timestamp is not None
        assert len(report.subsystems) == 1
        assert len(report.metrics) == 1
        assert isinstance(report.entropy_bottlenecks, list)
        assert isinstance(report.coupling_drifts, list)
        assert isinstance(report.phase_risk, PhaseTransitionRisk)
        assert isinstance(report.invariant_signatures, list)
        assert isinstance(report.mitigation_recommendations, list)
    
    def test_format_metrics_table(self):
        """Test formatting metrics report as table."""
        engine = VulnerabilityDiscoveryEngine()
        
        subsystem = Subsystem(
            subsystem_id="test_001",
            name="Test Subsystem",
            subsystem_type=SubsystemType.GENOMICS_PIPELINE,
            description="Test"
        )
        
        engine.enumerate_subsystem(subsystem)
        
        report = engine.generate_metrics_report()
        table = engine.format_metrics_table(report)
        
        assert isinstance(table, str)
        assert len(table) > 0
        assert "QRATUM VULNERABILITY METRICS REPORT" in table
        assert "Test Subsystem" in table
    
    def test_extract_invariant_signatures(self):
        """Test extracting invariant failure signatures."""
        engine = VulnerabilityDiscoveryEngine()
        
        subsystem = Subsystem(
            subsystem_id="test_001",
            name="Test Subsystem",
            subsystem_type=SubsystemType.GENOMICS_PIPELINE,
            description="Test",
            interfaces=["if1"] * 10,  # High complexity
            dependencies=["d1"] * 10
        )
        
        engine.enumerate_subsystem(subsystem)
        
        signatures = engine.extract_invariant_signatures()
        
        assert isinstance(signatures, list)
    
    def test_generate_mitigation_architecture(self):
        """Test generating mitigation recommendations."""
        engine = VulnerabilityDiscoveryEngine()
        
        subsystem = Subsystem(
            subsystem_id="test_001",
            name="Test Subsystem",
            subsystem_type=SubsystemType.GENOMICS_PIPELINE,
            description="Test"
        )
        
        engine.enumerate_subsystem(subsystem)
        
        metrics = {"test_001": engine.compute_latent_risk_metrics("test_001")}
        entropy_bottlenecks = engine.detect_entropy_bottlenecks()
        coupling_drifts = engine.track_coupling_drift()
        phase_risk = engine.model_phase_transition()
        
        recommendations = engine.generate_mitigation_architecture(
            metrics, entropy_bottlenecks, coupling_drifts, phase_risk
        )
        
        assert isinstance(recommendations, list)
    
    def test_export_report_json(self, tmp_path):
        """Test exporting report to JSON."""
        engine = VulnerabilityDiscoveryEngine()
        
        subsystem = Subsystem(
            subsystem_id="test_001",
            name="Test Subsystem",
            subsystem_type=SubsystemType.GENOMICS_PIPELINE,
            description="Test"
        )
        
        engine.enumerate_subsystem(subsystem)
        
        report = engine.generate_metrics_report()
        
        output_file = tmp_path / "test_report.json"
        engine.export_report_json(report, str(output_file))
        
        assert output_file.exists()
        
        import json
        with open(output_file) as f:
            data = json.load(f)
        
        assert "timestamp" in data
        assert "subsystems" in data
        assert "metrics" in data
        assert "phase_risk" in data


class TestIntegration:
    """Integration tests for the vulnerability discovery engine."""
    
    def test_full_qratum_analysis(self):
        """Test full QRATUM stack analysis."""
        engine = VulnerabilityDiscoveryEngine()
        
        # Create a simplified QRATUM stack
        subsystems = [
            Subsystem("genomics", "Genomics", SubsystemType.GENOMICS_PIPELINE, "Genomics pipeline"),
            Subsystem("aion", "AION", SubsystemType.AION_RUNTIME, "Runtime"),
            Subsystem("data", "Data", SubsystemType.DATA_INGESTION, "Data ingestion"),
            Subsystem("merkle", "Merkle", SubsystemType.MERKLE_CHAIN, "Merkle chain"),
        ]
        
        for subsystem in subsystems:
            engine.enumerate_subsystem(subsystem)
        
        # Add interfaces
        interfaces = [
            Interface("if1", "Data to Genomics", InterfaceType.DATA_FLOW, "data", "genomics", "gRPC"),
            Interface("if2", "AION to Merkle", InterfaceType.RPC_CALL, "aion", "merkle", "RPC"),
        ]
        
        for interface in interfaces:
            engine.register_interface(interface)
        
        # Generate report
        report = engine.generate_metrics_report()
        
        # Verify report completeness
        assert len(report.subsystems) == 4
        assert len(report.metrics) == 4
        assert report.phase_risk is not None
        
        # Format and verify output
        table = engine.format_metrics_table(report)
        assert len(table) > 0
        
        # Verify all subsystems have metrics
        for subsystem in subsystems:
            assert subsystem.subsystem_id in report.metrics


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
