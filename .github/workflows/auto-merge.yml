name: Auto-Merge PRs

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled]
  check_suite:
    types: [completed]
  workflow_run:
    workflows: ["CI - Lint, Test, and Validate", "Code Review & Auto-Fix"]
    types: [completed]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to evaluate for auto-merge'
        required: true
        type: number

permissions:
  contents: write
  pull-requests: write
  checks: read
  statuses: read

jobs:
  evaluate-auto-merge:
    name: Evaluate PR for Auto-Merge
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install PyGithub pyyaml
      
      - name: Evaluate PR for auto-merge
        id: evaluate
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.inputs.pr_number || github.event.pull_request.number }}
        run: |
          cat > evaluate_merge.py << 'EOFPY'
          #!/usr/bin/env python3
          import os
          import sys
          from github import Github, GithubException
          
          def check_pr_ready_for_merge(pr):
              """Check if PR meets all criteria for auto-merge"""
              issues = []
              
              # Check if PR is draft
              if pr.draft:
                  issues.append("PR is a draft")
                  return False, issues
              
              # Check if PR is mergeable
              if pr.mergeable is False:
                  issues.append("PR has merge conflicts")
              
              # Check if PR has the auto-merge label
              labels = [label.name for label in pr.labels]
              if 'auto-merge' not in labels and 'automerge' not in labels:
                  issues.append("PR does not have 'auto-merge' or 'automerge' label")
              
              # Check if PR has blocking labels
              blocking_labels = ['do-not-merge', 'wip', 'needs-work', 'needs-manual-review']
              if any(label in labels for label in blocking_labels):
                  issues.append(f"PR has blocking label(s): {[l for l in labels if l in blocking_labels]}")
                  return False, issues
              
              # Check CI status
              commit = pr.head.sha
              statuses = list(pr.base.repo.get_commit(commit).get_statuses())
              check_runs = list(pr.base.repo.get_commit(commit).get_check_runs())
              
              # Get latest status for each context
              latest_statuses = {}
              for status in statuses:
                  if status.context not in latest_statuses:
                      latest_statuses[status.context] = status
              
              # Check for failed statuses
              failed_statuses = [s.context for s in latest_statuses.values() if s.state == 'failure']
              if failed_statuses:
                  issues.append(f"Failed CI checks: {failed_statuses}")
              
              # Check for failed check runs
              failed_checks = [run.name for run in check_runs if run.conclusion == 'failure']
              if failed_checks:
                  issues.append(f"Failed check runs: {failed_checks}")
              
              # Check for pending checks
              pending_statuses = [s.context for s in latest_statuses.values() if s.state == 'pending']
              pending_checks = [run.name for run in check_runs if run.status != 'completed']
              if pending_statuses or pending_checks:
                  issues.append("CI checks are still pending")
                  return False, issues
              
              # Check if all required checks have passed
              required_success = True
              if statuses or check_runs:
                  passed_statuses = [s for s in latest_statuses.values() if s.state == 'success']
                  passed_checks = [r for r in check_runs if r.conclusion == 'success']
                  
                  if not (passed_statuses or passed_checks):
                      issues.append("No successful CI checks found")
                      required_success = False
              
              # Check for required approvals
              reviews = list(pr.get_reviews())
              if reviews:
                  latest_reviews = {}
                  for review in reviews:
                      latest_reviews[review.user.login] = review
                  
                  approvals = [r for r in latest_reviews.values() if r.state == 'APPROVED']
                  changes_requested = [r for r in latest_reviews.values() if r.state == 'CHANGES_REQUESTED']
                  
                  if changes_requested:
                      issues.append(f"Changes requested by: {[r.user.login for r in changes_requested]}")
                      return False, issues
              
              # Determine if ready
              can_merge = (
                  pr.mergeable is not False and
                  not failed_statuses and
                  not failed_checks and
                  required_success and
                  ('auto-merge' in labels or 'automerge' in labels)
              )
              
              return can_merge, issues
          
          def main():
              github_token = os.environ.get('GITHUB_TOKEN')
              pr_number = os.environ.get('PR_NUMBER')
              
              if not github_token or not pr_number:
                  print("ERROR: Missing GITHUB_TOKEN or PR_NUMBER")
                  sys.exit(1)
              
              gh = Github(github_token)
              repo = gh.get_repo(os.environ.get('GITHUB_REPOSITORY'))
              
              try:
                  pr = repo.get_pull(int(pr_number))
              except GithubException as e:
                  print(f"ERROR: Could not fetch PR #{pr_number}: {e}")
                  sys.exit(1)
              
              print(f"Evaluating PR #{pr.number}: {pr.title}")
              
              can_merge, issues = check_pr_ready_for_merge(pr)
              
              if can_merge:
                  print("âœ… PR is ready for auto-merge")
                  print("MERGE=true")
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write('can_merge=true\n')
                      f.write(f'merge_method=squash\n')
              else:
                  print("âŒ PR is not ready for auto-merge")
                  print("Issues:")
                  for issue in issues:
                      print(f"  - {issue}")
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write('can_merge=false\n')
                      f.write(f'issues={"|".join(issues)}\n')
          
          if __name__ == '__main__':
              main()
          EOFPY
          
          python evaluate_merge.py
      
      - name: Auto-merge PR
        if: steps.evaluate.outputs.can_merge == 'true'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ github.event.inputs.pr_number || github.event.pull_request.number }}
          MERGE_METHOD: ${{ steps.evaluate.outputs.merge_method }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);
            const mergeMethod = process.env.MERGE_METHOD || 'squash';
            
            try {
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              
              // Final check - ensure PR is still mergeable
              if (!pr.mergeable) {
                core.warning('PR is not mergeable - skipping auto-merge');
                return;
              }
              
              // Merge the PR
              const { data: mergeResult } = await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                commit_title: `${pr.title} (#${prNumber})`,
                commit_message: 'Auto-merged by GitHub Actions workflow',
                merge_method: mergeMethod
              });
              
              core.notice(`âœ… Successfully auto-merged PR #${prNumber}: ${mergeResult.sha}`);
              
              // Add comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `âœ… **Auto-merged successfully**\n\nThis PR met all the criteria for auto-merge:\n- All CI checks passed\n- No merge conflicts\n- Has the \`auto-merge\` label\n- No blocking labels\n\nMerge SHA: \`${mergeResult.sha}\``
              });
              
              // Try to delete the branch if it's not protected
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${pr.head.ref}`
                });
                core.notice(`Deleted branch ${pr.head.ref}`);
              } catch (error) {
                core.info(`Could not delete branch ${pr.head.ref}: ${error.message}`);
              }
              
            } catch (error) {
              core.setFailed(`Failed to auto-merge PR: ${error.message}`);
            }
      
      - name: Comment on PR if not ready
        if: steps.evaluate.outputs.can_merge == 'false' && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
          ISSUES: ${{ steps.evaluate.outputs.issues }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);
            const issues = (process.env.ISSUES || '').split('|').filter(i => i);
            
            if (issues.length === 0) return;
            
            let comment = `## ğŸ¤– Auto-Merge Status\n\n`;
            comment += `This PR is not yet ready for auto-merge. Please address the following:\n\n`;
            
            for (const issue of issues) {
              comment += `- ${issue}\n`;
            }
            
            comment += `\n### To enable auto-merge:\n`;
            comment += `1. Ensure all CI checks pass âœ…\n`;
            comment += `2. Resolve any merge conflicts ğŸ”€\n`;
            comment += `3. Add the \`auto-merge\` label ğŸ·ï¸\n`;
            comment += `4. Remove any blocking labels (e.g., \`do-not-merge\`, \`wip\`)\n`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: comment
            });
